---
layout:     post
title:      Reading Notes on "Hackers and Painters"
date:       2018-07-08 16:00:00
summary:    Recently I am reading the book "Hackers and Painters", which mainly introduces the hobbies and motivations of hackers, i.e., excellent programmers, discusses hacker growth, hacker's contribution to the world, programming languages and hacker working methods, and other topics for everyone interested in the computer age. This article is used to record some notes and thoughts during reading.
categories: Study
feature: https://gw.alicdn.com/imgextra/i1/O1CN01VdLKpO1NIZVXL67I7_!!6000000001547-0-tps-6016-4016.jpg
---

<img src="https://gw.alipayobjects.com/zos/rmsportal/CGfCazNqMVyiXccOVnJY.jpg" width="900"/>

## Start

Recently I am reading the book "Hackers and Painters", which mainly introduces the hobbies and motivations of hackers, i.e., excellent programmers, discusses hacker growth, hacker's contribution to the world, programming languages and hacker working methods, and other topics for everyone interested in the computer age. This article is used to record some notes and thoughts during reading.

## 1. Why nerds are unpopular

### Why?

Because nerds really don't want to make themselves popular. They think about other things in their minds. Their attention is on reading or observing the world to make themselves smarter, rather than pondering dressing up and socializing to make themselves popular.

### Interesting Views

- **For any kind of art, regardless of whether it is important, if you want to excel in that field, you must devote yourself wholeheartedly.**
- For those highly difficult fields, only those who are in them can realize that success requires continuous (though not necessarily conscious) effort.

### Places not very agreeable

> Almost everyone I discussed with agreed that the worst period of life was between 11 and 14 years old."

I don't quite agree here. It should be that the author had enough of the shadow formed by being bullied by those popular kids during that time period. At the same time, those people who communicated with him happened to be that kind of unpopular "nerds".

> As for schools, they are nothing more than pens to keep livestock in this fake environment. Superficially, the mission of the school is to educate children. In fact, the real purpose of the school is to lock children in the same place so that adults can free their hands to finish things during the day.

Seeing this sentence, it can be seen that the author really had shadows in his adolescence. Also not very agreeable. In the future, if I have children, I need to guide them well;

However, in the whole book, most of the views still agree with the author.

## 2. Hackers and Painters

Before reading this book, I always didn't want to call myself a code farmer, feeling like a repetitive laborer without thinking. More wanted to be a craftsman, make some interesting things through the tool of code, and make money by the way, getting the best of both worlds.

### Relationship

The author says "Hackers and painters are most alike", very agreeable. **The commonality between hackers and painters is that they are both creators. Like composers, architects, and writers, hackers and painters are trying to create excellent works. They are essentially not doing research, although in the process of creation, they may discover some new technologies.**

What hackers really want to do is design beautiful software. Assessing this kind of work is very difficult. You yourself need to have a good sense of design to assess whether other people's design is good. But, whether you think you have a "good sense of design" has no correlation with whether you actually have it, and may even have a negative correlation.

Then an example of university computer practice was given. The school taught to figure out the program on paper first, and then type it out. This is exactly the same as writers, painters and architects. His way is regardless of right or wrong, pile up the code first, and then modify it slowly. It looks like programming is debugging.

### Interesting Points

- In order to avoid disasters in design, big companies chose to reduce the standard deviation of design results. But when you reject differences, you not only exclude the possibility of failure, but also exclude the possibility of high profits. This is also one of the reasons why startups can succeed.
- The way for hackers to solve livelihood problems is to find a "day job" and then develop beautiful software in the rest of the time.
- **Hackers learn programming through practice. Another way for creators to learn is through examples. You can learn programming by watching excellent source code.**
- For programming, this actually means you can leave bugs to be solved later. Eliminating bugs is an easy job for me. Only at this time, programming becomes direct and mechanical, close to the appearance of programming in the imagination of the public.

### Thinking

> Among all the differences between ordinary hackers and excellent hackers, could "empathy" be the most important single factor?

Empathy here refers to putting oneself in the user's shoes. How to assess whether a person possesses it? **It is to see how he explains technical problems to people without technical background**. Increasingly feel that how to explain what you understand to people who don't understand certain technology very well so that they can easily understand it tests people's ability very much.

> Programs are written for people to read, incidentally run on machines.

Very much agree with this sentence. Programs are written to let people understand its algorithm, incidentally telling the computer how to execute. "A good programming language should explain software easier than English. Only in those immature, prone-to-problem places, should you add comments to remind readers to pay attention there, just like warning signs only appear at sharp turns on the highway.

Many people think that writing code that reflects technology very well is an experience of high level and high ability. Actually not. Solving complex problems with simple code, code that interns can easily understand is good code.

## 3. Unspeakable Words

The author is relatively cautious, believing that no matter what era, "disaster comes from the mouth" always exists, warning readers to be careful about what they say. Remarks thought to be harmless will bring you big trouble.

### Are you a conformist?

If in public, do you have any views that you are unwilling to say? If not, you should think about it carefully. It is possible **your views are heard from others. You believe whatever others tell you. You take the views instilled by others as your own views.**

In order to prevent others from copying, ancient craftsmen who made maps would deliberately draw a small place wrong on the map. If your map is the same as his map, it means it is unlikely that you made it independently.

Our thoughts are almost certainly also a map with errors. If you also make the same mistakes as others, then this mistake is unlikely to come entirely from yourself.

### Methods to find "Unspeakable Words"

- **Judge the authenticity of remarks**: When words cannot be spoken, while they are correct or likely correct, worthy of further discussion.
- **Pay attention to "heresy"**: Some ideas, purely because they are very special, the kind that cannot be spoken, highly controversial remarks are called "heresy".
- **Review the past**. We can look for things that were considered granted in the past but are now considered incredible.
- **Look for those solemn defenders of the faith and see what they are defending.**
- **Observe how taboos are generated**

### Why do this?

- Pure curiosity, for the same reason as children turning over stones, want to see with own eyes, and then make decisions by themselves.
- Don't like making mistakes, hope to know what things are, so that I won't be fooled.
- Good mental training. To make excellent works, you need a brain that can think about any problem.

### What to do after discovery

- Don't say it, at least pick a suitable occasion to say it, only fight those battles worth fighting.
- Draw a clear line between thought and speech. Think everything in mind, but don't necessarily say it out.
- Keep mouth shut, smile to welcome, although cannot enjoy the benefits brought by discussion, but can find some trusted confidants, only speak freely with them.

### Interesting Points

- If you don't even dare to think about places where you don't agree with society, and give up your own views immediately, that will really be a problem.
- **Excellent works often come from ideas ignored by others, and the most ignored ideas are those prohibited ideological views.**
- The higher the intelligence, the more willing to think about those shocking ideological views. This is not only because smart people themselves actively look for loopholes in traditional concepts, but also because traditional concepts have little binding force on them and are easy to get rid of.

### Thinking

> Training yourself to think about those unthinkable things, the benefits you get will exceed the ideas themselves.

But generally like to do things one likes first. For things one doesn't want to do, drag as long as possible. Little do they know that they have been in the original thinking circle, cannot jump out, no innovation at all.

> If you want to think clearly, you must stay away from the crowd. But the farther you go, the more difficult your situation will be, and the greater the resistance you will encounter, because you did not cater to social customs, but went against it step by step.

That is to be yourself, follow your heart, don't drift with the tide.

## 4. Good Bad Habits

For programmers, the literal meaning of the word "hacker" is mainly "proficient", that is, he can dominate the computer as he wishes. "Hack" also has a meaning of praise. If the way you solve problems is very smart and superb, manipulating the entire system in the palm of your hand, this is also called you are very "hack".

Then the author told an example of wanting to learn lock picking. The reason was not thinking about cracking to do bad things, but to satisfy curiosity, or hone one's intellect.

The good bad habits mentioned here, I understand should be a mentality of keeping curiosity about new things, loving freedom, and not loving control.

### Interesting Points

- Only by deeply understanding current technology can hackers conceive next-generation technology.
- In the history of computer industry, new technologies are often developed by external personnel, and the proportion may be higher than internal personnel.
- For appropriate disobedience to discipline, maintaining tolerance will not do much harm, but is very beneficial to America's national advantage. It allows America not only to attract smart people, but also to attract those who are very conceited.

## 5. Another Road

When the author started a business at that time, he originally planned to write a traditional desktop software, but thought that software could run on the server, with the browser as the operation interface. We tried to rewrite, letting all operations be done through the network.

He saw things very thoroughly, thinking that for users, in fact, many things do not need attention. Messy, frequently changing things are all placed on the server side, maintained by professionals proficient in this way. Users do not need to be "system administrators" themselves. This way is easier, cheaper, more mobile, more reliable, and usually more powerful than desktop software.

### Victory of Users

Thinking in 95, death before inconvenience.

Internet operations should not be restricted by geography, can be used anywhere. Actually, web pages are more convenient to use than desktop software installed on computers.

The concept of "Your computer" is slowly becoming past tense, replaced by "Your data". You should be able to get your data from any computer. Or more accurately, get your data on any terminal device. The terminal device does not necessarily have to be a computer.

The benefits of Internet software for users are: no installation needed, rapid release, smooth upgrade, rapid bug fix, can be used by multiple people at the same time, data is safer, etc.

### Interesting Points

- For **Internet software, no one stipulates that only certain languages can be used for development**, because all hardware is controlled in your hands. You can use whatever language you want. Different languages are suitable for different tasks. You should choose the most suitable tool according to different occasions, especially in the presence of competitors, "can do this" becomes "must do this", because if you don't use the advantage of language, you will let the opponent surpass you.
- "With the increase of software scale, development cost rises exponentially. This may be due to fixing old bugs. If bugs can be discovered quickly, the rising form of cost can basically remain linear."
- Whenever possible, commercial companies will adopt a pricing method called "price discrimination", that is, giving different quotes for different customers to maximize profits.
- Managing an enterprise is actually very simple, just remember two points: **Make products that users like, ensure expenses are less than income**.

### Thinking

> Users should be allowed to subscribe to the usage rights of software according to the length of use time like subscribing to newspapers.

Remembering the subscription methods of software on some mac, iphone, I didn't understand before. In fact, this is good for both developers/users. Developers can continue to upgrade and bring better experience to users.

For software developers, this is an ideal source of income. There is a continuous cash flow every quarter, and at the same time can better manage people who buy software (don't pay, can't use it later...).

For buyers, I like it. Next time I can not subscribe, which is also relatively convenient.

> Many farms use electric fences to prevent cows from escaping, but many electric fences are actually not electrified. However, the cows have already suffered, obviously learned not to touch the electric fence. At this time, not electrifying can also have an effect. "Cows, act!" he wrote, "While the rulers are snoring, take back your freedom!"

That is to say, why not try it? The author talks about entrepreneurship, but most hackers will have two things that deter them, dare not really start to take action. One is not knowing how to manage an enterprise, the other is fear of competition. But in fact, these two things are electric fences without electricity. Actually can try.

## 6. How to Create Wealth

**The author believes the best way is to start a business, or join a startup company.**

### Why?

Entrepreneurship is actually a compression process. All your working years are compressed into a few short years. In the high-tech field, the return is particularly generous. The higher the work efficiency, the higher the extra reward.

Secondly, working time in startup is 2 times of company time. Plus concentration, output increases 3 times. Remove middle management layer, efficiency increases 2 times. At the same time, no need to complete tasks forcibly assigned by superiors, try to play smart according to own wishes, efficiency increases 3 times. That is, work efficiency is 36 times that in the company. That is, previously 80,000 dollars a year, now can be 3 million dollars a year. (Of course, the premise is a hacker...)

### Component of Luck

In the success history of any company, luck is a big random factor. Those successful people you read in the newspaper are certainly smart and hard-working, but their luck is not bad either.

Here cited an example of Bill Gates. The licensing agreement between IBM and Microsoft on DOS operating system was a mistake made by IBM. IBM did its best to help Microsoft control the standard of personal computers. From then on, Microsoft only needed to keep making products. It never had to make decisions with commercial risks. Microsoft only needed to hold on to the licensing agreement and quickly copy new products.

There are many ways to get rich (speculation, marriage, inheritance, theft, extortion, fraud, monopoly, bribery, lobbying, counterfeiting, mining, etc.). At that time, the above were probably getting something for nothing or illegal. Here mainly talks about **getting rich by creating valuable things and getting returns in the market**, which is both legal and simple.

### Money does not equal wealth

Creating valuable things is creating wealth. Before, I always thought having money means having wealth. Actually not. What we need is wealth. Food, clothing, housing, cars, daily necessities, travel, etc. are all wealth. Even if you don't have money, you can possess wealth.

For example, if you are in the interior of Antarctica, no matter how much money you have, it is useless to you, because there is nothing to buy. What you really need is wealth.

Then why does everyone talk about making money? Part of the reason is that money is a convenient expression of wealth: money is a bit like liquid wealth. The two can often be transformed into each other, but not wealth, but just something we use to transfer ownership of wealth.

### Craftsmen

The people most likely to understand that wealth can be created are those who are good at making things, that is, craftsmen. The things they make are sold directly in stores. However, with the advent of the industrial age, there are fewer and fewer craftsmen. **The largest group of craftsmen still existing is programmers.**

### What is work

Work is to cooperate with many people in an organization to make something people need.

### Work Harder

Big companies will average each employee's contribution. This is a problem. I think the biggest trouble for big companies is unable to accurately measure each employee's contribution.

However, the reality is that the more energy you put into work, the more scale effect can be produced. In some industries, those employees who really work hard can create ten times or even a hundred times more wealth than ordinary employees.

This also points out a disadvantage of big companies. Your work cannot be quantified, contribution is difficult to measure, leading to many wanting to work harder, but mixed with work of many others. This creates problems. Others in the company will drag you down.

### Measurability and Scalability

To get rich, you need two things: **Measurability and Scalability**. The performance produced by your position should be measurable, otherwise no matter how much you do, you won't get more pay. In addition, you must also have scalability, meaning the decisions you make can produce huge effects.

However, if you want to possess both measurability and scalability, you don't necessarily have to be a CEO or movie star. You just need to become part of a small group tackling difficult problems.

Small group = Measurability, High tech = Scalability

A very capable person who cares about returns usually performs better in a small team composed of similar people, and will feel more satisfied himself.

At the same time, most people who get rich by creating wealth are realized by developing new technologies.

### Hidden Rules of Entrepreneurship

- Many things are not up to you. After really starting a business, your competitors decide how hard you have to work, and the decisions they make are the same: We can endure as much hardship as you can.
- Although the effort and return of entrepreneurship are generally proportional, they are disproportionate individually.

### Interesting Points

- A startup company is actually a small company that solves a certain technical problem.
- If you want to earn 1 million dollars, you have to endure pain equivalent to 1 million dollars.
- **Creating things people need is creating wealth.**
- College life is very interesting, but it has passed. Why is working days so different? Don't be confused, you have now changed from a customer to a servant.

### Thinking

> What is technology? Technology is a certain means, the way we do things. If you discover a new way of doing things, its economic value depends on how many people use this new way.

A very sensible sentence. Often, technical people will have a misunderstanding, feeling they are very powerful, but no one uses the thing at all. This is actually bad. Its value depends on how many people are using it, and whether it can solve problems.

> Suppose you are a nimble little boy, with a sturdy big dog chasing you behind. You run to the stairs, should you go up or down at this time? I think should go up. If going down, the big dog might run as fast as you. Going up, the big dog's huge body will become a disadvantage. Yes, running upstairs you will be more strenuous, but the big dog will feel more strenuous.

In life and work, it should also be like this. Should **deliberately choose those very difficult technical problems**, not because this function can bring more income, but because it is relatively difficult, that is **barriers to entry**. Actually doing technology should also be like this, so it is interesting.

In general, this is also a good principle of conduct. If you have two choices, choose the harder one. If you have to choose between sitting at home watching TV or going out for a run, then go out for a run. The reason why this method is effective may be that when encountering two choices, one hard and one easy, often due to laziness, you will choose the easier option. Deep in consciousness, **you actually know that not being lazy will bring better results. This method just forces you to accept this point.**

## 7. Focus on Wealth Differentiation

When people really want to do something well, some people will do much better than others.

We say some jobs are overpaid, other jobs are underpaid. What exactly is our real thought? In a free competitive market economy, price is determined by buyer's demand. If people like baseball more than poetry, then baseball players' income is higher than poets'. If saying a certain job is underpaid, it is equivalent to saying people's demand is incorrect. Of course, people do demand incorrect things.

### Interesting Points

- How much value a person's work has is not determined by the government, but by the market.
- Technology's improvement on production efficiency is not linear, but may be polynomial.
- The only thing technology cannot make cheaper is brand.

## 8. A Method to Prevent Spam

This section is not very meaningful for the current era. The author **believes that filtering spam is achievable, content-based filters will work.** But in his era, it was very meaningful.

Bayesian judgment on individual words can filter most spam very well. Later made a filter through statistical methods, actually a bit like current machine learning.

## 9. Designer's Taste

Here discusses "How to make beautiful products". Principles of excellent design are common principles of many disciplines, appearing repeatedly.

### Many disciplines' understanding of beauty

- Good design is simple design.
- Good design is timeless design.
- Good design is design that solves main problems.
- Good design is inspiring design.
- Good design is usually somewhat interesting design.
- Good design is arduous design.
- Good design is seemingly easy design.
- Good design is symmetrical design.
- Good design is design mimicking nature.
- Good design is a redesign.
- Good design is copyable design.
- Good design is often strange design.
- Good design appears in batches.
- Good design is often bold design.

### Interesting Points

- Copernicus did not agree with Ptolemy's system. An extremely important reason is that he felt the equant proposed by Ptolemy had no aesthetic feeling...
- The secret of excellent works is: very strict taste, plus the ability to realize this taste.

## 10. Programming Language Parsing

Computers, like other machines, have a list of operation commands. The sum of commands is the computer's machine language.

### Machine Language

When computers were just invented, all programs were lines of machine language commands. Not long after, programs changed to use assembly language, which is slightly more convenient to write than machine language. The command list is still the same, just replaced each command with a more humane name.
The common feature of both is: can only let most computers do some very simple things.

### High-level Language

The language used by programs written in a convenient way is called high-level language, allowing you to use more powerful commands to develop programs.
Besides being able to write code more briefly, there is another advantage, portability.

High-level languages can be implemented using **compilers** or **interpreters**. The difference is that the former translates the entire program into machine language first, then runs it. The latter interprets code into corresponding machine language in real time, then runs line by line.

High-level language code processed by compiler is also called source code. The machine code generated after translation is called object code.

### Interesting Points

- The more code required for an operation, the harder it is to avoid bugs, and the harder it is to find them.
- **If you use a certain language for a long time, you will slowly think according to the thinking mode of this language.** So, later when you encounter any other language with significant differences, even if there is nothing wrong with that language itself, you will feel it extremely difficult to use. Inexperienced programmers' judgment on advantages and disadvantages of various languages is often misled by this mentality.

#### Thinking

> A small car with an aircraft engine tied to the roof might actually drive. As long as you don't try to turn, there might be no problem.

The new "top-heavy" programming languages mentioned here appearing later, their kernel design is not very good, but have countless powerful libraries, can be used to solve specific problems. Can imagine a small car with poor performance itself, but tied with an aircraft engine on the roof.

There are some very trivial, very common problems. Programmers originally had to spend a lot of time to solve them, but with these libraries, solving becomes very easy, so these libraries themselves may be more important than the core language.

This also better explains why hackers don't like using languages like C.

## 11. Programming Language After A Hundred Years

Programming languages are like biological species, there is an evolutionary context. Many branches will eventually become evolutionary dead ends.
That is, languages of different branches will aggregate, because language designers always consciously borrow design ideas from other languages.

The author believes that those programming languages with the smallest and cleanest kernels will exist on the main trunk of evolution. The smaller and cleaner a language's kernel is designed, the more tenacious its vitality.

### Interesting Points

- A language that makes programmers do useless work can really be called lousy. Wasting programmer's time instead of machine's time is the real inefficiency. As computer speed gets faster and faster, this will become more and more obvious.
- Programming language after a hundred years can theoretically be designed today; if such a language can really be designed today, it is likely suitable for programming now, and can produce better results.

## 12. Reject Mediocrity

Haha, in this section, the author is promoting Lisp language. Reminds me of SICP read before, a bit profound, need to read again to understand. He said people who really seriously take hackers as life goals should consider learning Lisp:

> Lisp is worth learning. After you master it, you will feel the great inspiration it brings you. This will greatly improve your programming level, making you a better programmer. Although Lisp is rarely used in actual work.

### Interesting Points

- The benefit of Lisp language is not that it has some advantages only fanatical enthusiasts understand, but only that it is currently the most powerful programming language. The reason why it has not been widely used is because programming language is not only technology, but also a habitual thinking, very difficult to change. Of course, the above two sentences need further explanation.
- Aikido is a Japanese martial art, main features are "overcoming rigidity with softness", "borrowing strength to use force", "not attacking actively".

## 13. Revenge of the Nerds

"Conflict problem" between product managers and programmers. One knows nothing about technology; one has strong personal views on technology.

Speaking of which, Lisp is mentioned again. Why is it special? When Lisp language was born, it contained 9 new ideas. Some of them we are accustomed to today, others just appeared in other high-level languages, and there are still 2 unique to Lisp so far.

### Why Lisp language is special

- Conditional structure (i.e. if-then-else structure)
- Function is also a data type. In Lisp language, function belongs to one of data types just like integer or string. It has its own literal representation, can be stored in variables, and can also be passed as parameters. It has all the functions a data type should have.
- Recursion. Lisp is the first high-level language supporting recursive functions.
- Dynamic typing of variables. In Lisp language, all variables are actually pointers. Pointed values have types, but variables themselves do not. Copying variable is equivalent to copying pointer, not copying data they point to.
- Garbage collection mechanism.
- Program consists of expressions. Lisp program is a collection of expression trees. Each expression returns a value. This is completely different from Fortran and most later languages, whose programs consist of expressions and statements.
- Symbol type. Symbol is actually a pointer, pointing to string stored in hash table. So, comparing whether two symbols are equal, just look if their pointers are same, no need to compare character by character.
- Code uses tree notation composed of symbols and constants.
- The whole language is available at any time. Lisp does not really distinguish reading period, compilation period and running period.

### Interesting Points

- Any C or Fortran program complicated to a certain extent will contain a temporarily developed, only half-functional, not fully compliant with specifications, buggy everywhere, slow-running Common Lisp implementation.

## 14. Dream Programming Language

This language is clean and concise, with highest level of abstraction and interactivity, and very easy to equip. Can solve common problems with very little code. No matter what program, the code you really want to write is almost all related to your own specific settings. Other universal problems have ready-made libraries to call.

This language has a large number of excellent examples for learning, and is very intuitive. You only need to spend a few minutes reading examples to comprehend how to use this language.

This language is built in layers. Higher abstraction layer is transparently built on lower abstraction layer. If needed, you can directly use lower abstraction layer.

All details of this language are transparent to users. The abstraction capability it provides is only to facilitate your development, not to force you to act in its way.

### Conciseness

- The most important aspect of conciseness is to make language more abstract. To achieve this, first you must design a high-level language, then design it as abstract as possible.
- Don't think considering for users is letting them use grammar as long and wordy as English.
- Individual grammatical units should also be very short.

### Hackability

- When choosing programming language, there is another factor more important than conciseness, that is this language must be able to help oneself do what one wants to do.

### Disposable Program

- So-called disposable program refers to program written in a very short time to complete some very simple temporary tasks.
- It must be very easy to equip. Disposable program is program you only want to write in one hour, so it shouldn't cost a lot of time to install and configure, preferably already installed on your computer. It must be usable whenever wanted.

### Libraries

- Library is program written by others to help you.
- The importance of excellent libraries will exceed the language itself.

### Efficiency

- The key to improving code running speed when programming is to use good profilers.

### Time

- For a programming language to become popular, the last hurdle is to withstand the test of time. No one wants to program in a language that will be eliminated.

### Redesign

- As long as "redesign" can go on repeatedly, it is desirable.

## 15. Design and Research

The difference between design and research seems to be that the former pursues "good", the latter pursues "new". Excellent design is not necessarily "new", but must be "good";

### Interesting Points

- To make excellent design, you must stay close to users, never leaving a step, always adjusting your ideas from user's perspective.
- Making prototype first, then gradually processing to make finished product. This way is conducive to boosting morale, because it allows you to see the results of work at any time.
- At any time, **code must be able to run**. If the code you are writing can see running results in an hour, this is like letting you see the reward within reach not far away, you will be motivated and inspired.

## End

Read this book for several weeks, finally finished reading and sorting out. Feel like taking notes in college. At the same time solved many of my confusions. Highly recommend programmers to read it when having time!
